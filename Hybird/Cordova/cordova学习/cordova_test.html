<script>
/*
cordova.js 的作用是封装了模块定义函数，并定义了需要的各种模块：
       模块                             file
    "cordova"                       src/cordova.js
    "cordova/argscheck"             src/common/argscheck.js
    "cordova/base64"                src/common/base64.js
    "cordova/builder"               src/common/builder.js
    "cordova/channel"               src/common/channel.js
    "cordova/exec"                  /项目路劲/wwwcordova-js-src/exec.js
    "cordova/exec/proxy"            src/common/exec/proxy.js
    "cordova/init"                  src/common/init.js
    "cordova/modulemapper"          src/common/modulemapper.js
    "cordova/platform"              /项目路劲/www/cordova-js-src/platform.js
    "cordova/plugin/ios/console"    /项目路劲/www/cordova-js-src/plugin/ios/console.js
    "cordova/plugin/ios/logger"     /项目路劲/www/cordova-js-src/plugin/ios/logger.js
    "cordova/pluginloader"          src/common/pluginloader.js
    "cordova/urlutil"               src/common/urlutil.js
    "cordova/utils"                 src/common/utils.js

    文件最后两行代码加载了全局`cordova`模块
*/

var PLATFORM_VERSION_BUILD_LABEL = '5.0.1';

// 生命两个全局变量，这里是手动实现了高版本的 require和define指令
// require、define都是函数
var require;
var define;

// 实现上面声明的两个函数
(function () {

    /*  存储所有模块的字典 
        modules = {
            'cordova-plugin-camera.camera' : {
                id: 'cordova-plugin-camera.camera',
                factory: factory...
            },
            'logger' : {
                id: 'logger',
                factory: factory...
            },
            .........
        }
    */
    var modules = {};


    // 用于存储正在构建的module的id的数组
    var requireStack = [];
    // 用于存储正在构建的module的id在requireStack中的索引的字典，映射关系： moduleID -> moduleId在requireStack数组中的索引
    var inProgressModules = {};
    var SEPARATOR = '.';

    /**
    * desc: 构建一个模块
    * param: module - 一个模块，数据结构为{id:moduleID, factory:function(require, exports, module)}
    * 
    * build的作用是执行一遍模块的factory工厂方法、获取模块的`module.exports`数据
    */
    function build (module) {
        var factory = module.factory;
        var localRequire = function (id) {
            var resultantId = id;
            // 传进来的id如果是相对路劲, 要砍掉模块id最后的部分, 并拼接参数id最后的部分
            if (id.charAt(0) === '.') {
                resultantId = module.id.slice(0, module.id.lastIndexOf(SEPARATOR)) + SEPARATOR + id.slice(2);
            }
            return require(resultantId);
        };
        module.exports = {};
        // 删除模块的factory方法后，模块数据结构变成了{id:moduleID}
        delete module.factory; 
        // 执行模块的工厂方法
        factory(localRequire, module.exports, module);
        // 将模块内暴露的数据全部导出
        return module.exports;
    }

    ////////////////////// 定义require ////////////////////////////
    require = function (id) {
        if (!modules[id]) {
            throw 'module ' + id + ' not found';
        } else if (id in inProgressModules) {
            var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;
            throw 'Cycle in require graph: ' + cycle;
        }
        if (modules[id].factory) {
            try {
                inProgressModules[id] = requireStack.length;
                requireStack.push(id);
                return build(modules[id]);
            } finally {
                delete inProgressModules[id];
                requireStack.pop();
            }
        }
        // 构建过的模块直接返回模块暴露的数据
        return modules[id].exports;
    };
    //////////////////////////////////////////////////

    ////////////////////// 定义define ////////////////////////////
    // 将模块存入 modules 字典
    define = function (id, factory) {
        if (modules[id]) {
            throw 'module ' + id + ' already defined';
        }

        modules[id] = {
            id: id,
            factory: factory
        };
    };
    //////////////////////////////////////////////////

    define.remove = function (id) {
        delete modules[id];
    };

    define.moduleMap = modules;
})();

// Export for use in node
if (typeof module === 'object' && typeof require === 'function') {
    module.exports.require = require;
    module.exports.define = define;
}

define("cordova", function(require, exports, module) {

    // Workaround for Windows 10 in hosted environment case
    // http://www.w3.org/html/wg/drafts/html/master/browsers.html#named-access-on-the-window-object
    if (window.cordova && !(window.cordova instanceof HTMLElement)) { // eslint-disable-line no-undef
        throw new Error('cordova already defined');
    }

    var channel = require('cordova/channel');
    var platform = require('cordova/platform');

    /**
    * 拦截 calls to addEventListener + removeEventListener and handle deviceready,
    * 恢复, and 暂停 events.
    */
    var m_document_addEventListener = document.addEventListener;
    var m_document_removeEventListener = document.removeEventListener;
    var m_window_addEventListener = window.addEventListener;
    var m_window_removeEventListener = window.removeEventListener;

    /**
    * Houses custom event handlers to intercept on document + window event listeners.
    */
    var documentEventHandlers = {};
    var windowEventHandlers = {};

////////////////////////////////////////////////////
///////////// ?????????????
///////////// 1. subscribe
///////////// 2. call
////////////////////////////////////////////////////
    document.addEventListener = function (evt, handler, capture) {
        var e = evt.toLowerCase();
        if (typeof documentEventHandlers[e] !== 'undefined') {
            documentEventHandlers[e].subscribe(handler);
        } else {
            m_document_addEventListener.call(document, evt, handler, capture);
        }
    };

    window.addEventListener = function (evt, handler, capture) {
        var e = evt.toLowerCase();
        if (typeof windowEventHandlers[e] !== 'undefined') {
            windowEventHandlers[e].subscribe(handler);
        } else {
            m_window_addEventListener.call(window, evt, handler, capture);
        }
    };

    document.removeEventListener = function (evt, handler, capture) {
        var e = evt.toLowerCase();
        // If unsubscribing from an event that is handled by a plugin
        if (typeof documentEventHandlers[e] !== 'undefined') {
            documentEventHandlers[e].unsubscribe(handler);
        } else {
            m_document_removeEventListener.call(document, evt, handler, capture);
        }
    };

    window.removeEventListener = function (evt, handler, capture) {
        var e = evt.toLowerCase();
        // If unsubscribing from an event that is handled by a plugin
        if (typeof windowEventHandlers[e] !== 'undefined') {
            windowEventHandlers[e].unsubscribe(handler);
        } else {
            m_window_removeEventListener.call(window, evt, handler, capture);
        }
    };

/*///////////////////////////////////////////////////
为DOM元素创建自定义事件的步骤为：
    一、创建事件：var ev = document.createEvent('CustomEvent');
    二、初始化事件：ev.initCustomEvent('自定义事件名称', false(是否允许冒泡), false(是否允许中断),args)
    三、为DOM添加事件监听：element.addEventListener('自定义事件名称',fn,false)
    四、分发(触发)自定义事件：element.dispatchEvent(ev)
///////////////////////////////////////////////////*/

    // type 是一个字符串，表示要创建的事件类型。
    // 事件类型可能包括"UIEvents", "MouseEvents", "MutationEvents", 或者 "HTMLEvents"。
    function createEvent (type, data) {
        // 创建事件
        var event = document.createEvent('Events');
        // 定义事件名为type.
        event.initEvent(type, false, false);
        if (data) {
            for (var i in data) {
                if (data.hasOwnProperty(i)) {
                    event[i] = data[i];
                }
            }
        }
        return event;
    }

    /* eslint-disable no-undef */
    var cordova = {
        define: define,
        require: require,
        version: PLATFORM_VERSION_BUILD_LABEL,
        platformVersion: PLATFORM_VERSION_BUILD_LABEL,
        platformId: platform.id,

        /* eslint-enable no-undef */

        /**
        * Methods to add/remove your own addEventListener hijacking on document + window.
        */
        addWindowEventHandler: function (event) {
            return (windowEventHandlers[event] = channel.create(event));
        },
        addStickyDocumentEventHandler: function (event) {
            return (documentEventHandlers[event] = channel.createSticky(event));
        },
        addDocumentEventHandler: function (event) {
            return (documentEventHandlers[event] = channel.create(event));
        },
        removeWindowEventHandler: function (event) {
            delete windowEventHandlers[event];
        },
        removeDocumentEventHandler: function (event) {
            delete documentEventHandlers[event];
        },
        /**
        * Retrieve original event handlers that were replaced by Cordova
        *
        * @return object
        */
        getOriginalHandlers: function () {
            return { 'document': { 'addEventListener': m_document_addEventListener, 'removeEventListener': m_document_removeEventListener },
                     'window': { 'addEventListener': m_window_addEventListener, 'removeEventListener': m_window_removeEventListener } };
        },
        /**
        * Method to 触发原生平台发起的事件
        * bNoDetach is required for events which cause an exception which needs to be caught in native code
        */
        fireDocumentEvent: function (type, data, bNoDetach) {
            var evt = createEvent(type, data);
            if (typeof documentEventHandlers[type] !== 'undefined') {
                if (bNoDetach) {
                    // 同步执行
                    documentEventHandlers[type].fire(evt);
                } else {
                    // 异步执行
                    setTimeout(function () {
                        // Fire deviceready on listeners that were registered before cordova.js was loaded.
                        if (type === 'deviceready') {
                            document.dispatchEvent(evt);
                        }
                        documentEventHandlers[type].fire(evt);
                    }, 0);
                }
            } else {
                document.dispatchEvent(evt);
            }
        },
        fireWindowEvent: function (type, data) {
            var evt = createEvent(type, data);
            if (typeof windowEventHandlers[type] !== 'undefined') {
                setTimeout(function () {
                    windowEventHandlers[type].fire(evt);
                }, 0);
            } else {
                window.dispatchEvent(evt);
            }
        },

        /**
        * Plugin callback mechanism --- 插件回调机制
        */
        // Randomize the starting callbackId to avoid collisions after refreshing or navigating.
        // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.
        callbackId: Math.floor(Math.random() * 2000000000),
        callbacks: {},
        callbackStatus: {
            NO_RESULT: 0,
            OK: 1,
            CLASS_NOT_FOUND_EXCEPTION: 2,
            ILLEGAL_ACCESS_EXCEPTION: 3,
            INSTANTIATION_EXCEPTION: 4,
            MALFORMED_URL_EXCEPTION: 5,
            IO_EXCEPTION: 6,
            INVALID_ACTION: 7,
            JSON_EXCEPTION: 8,
            ERROR: 9
        },

        /**
        * Called by native code when returning successful result from an action.
        */
        callbackSuccess: function (callbackId, args) {
            cordova.callbackFromNative(callbackId, true, args.status, [args.message], args.keepCallback);
        },

        /**
        * Called by native code when returning error result from an action.
        */
        callbackError: function (callbackId, args) {
            // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.
            // Derive success from status.
            cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);
        },

        /**
        * Called by native code when returning the result from an action.
        */
        callbackFromNative: function (callbackId, isSuccess, status, args, keepCallback) {
            try {
                var callback = cordova.callbacks[callbackId];
                if (callback) {
                    if (isSuccess && status === cordova.callbackStatus.OK) {
                        callback.success && callback.success.apply(null, args);
                    } else if (!isSuccess) {
                        callback.fail && callback.fail.apply(null, args);
                    }
                    /*
                    else
                        Note, this case is intentionally not caught.
                        this can happen if isSuccess is true, but callbackStatus is NO_RESULT
                        which is used to remove a callback from the list without calling the callbacks
                        typically keepCallback is false in this case
                    */
                    // Clear callback if not expecting any more results
                    if (!keepCallback) {
                        delete cordova.callbacks[callbackId];
                    }
                }
            } catch (err) {
                var msg = 'Error in ' + (isSuccess ? 'Success' : 'Error') + ' callbackId: ' + callbackId + ' : ' + err;
                console && console.log && console.log(msg);
                console && console.log && err.stack && console.log(err.stack);
                cordova.fireWindowEvent('cordovacallbackerror', { 'message': msg });
                throw err;
            }
        },
        
        addConstructor: function (func) {
            channel.onCordovaReady.subscribe(function () {
                try {
                    func();
                } catch (e) {
                    console.log('Failed to run constructor: ' + e);
                }
            });
        }
    };

    module.exports = cordova;

});

define("cordova/init", function(require, exports, module) {

    var channel = require('cordova/channel');
    var cordova = require('cordova');
    var modulemapper = require('cordova/modulemapper');
    var platform = require('cordova/platform');
    var pluginloader = require('cordova/pluginloader');
    var utils = require('cordova/utils');

    var platformInitChannelsArray = [channel.onNativeReady, channel.onPluginsReady];

    function logUnfiredChannels (arr) {
        for (var i = 0; i < arr.length; ++i) {
            if (arr[i].state !== 2) {
                console.log('Channel not fired: ' + arr[i].type);
            }
        }
    }

    window.setTimeout(function () {
        if (channel.onDeviceReady.state !== 2) {
            console.log('deviceready has not fired after 5 seconds.');
            logUnfiredChannels(platformInitChannelsArray);
            logUnfiredChannels(channel.deviceReadyChannelsArray);
        }
    }, 5000);

    // Replace navigator before any modules are required(), to ensure it happens as soon as possible.
    // We replace it so that properties that can't be clobbered can instead be overridden.
    function replaceNavigator (origNavigator) {
        var CordovaNavigator = function () {};
        CordovaNavigator.prototype = origNavigator;
        var newNavigator = new CordovaNavigator();
        // This work-around really only applies to new APIs that are newer than Function.bind.
        // Without it, APIs such as getGamepads() break.
        if (CordovaNavigator.bind) {
            for (var key in origNavigator) {
                if (typeof origNavigator[key] === 'function') {
                    newNavigator[key] = origNavigator[key].bind(origNavigator);
                } else {
                    (function (k) {
                        utils.defineGetterSetter(newNavigator, key, function () {
                            return origNavigator[k];
                        });
                    })(key);
                }
            }
        }
        return newNavigator;
    }

    if (window.navigator) {
        window.navigator = replaceNavigator(window.navigator);
    }

    if (!window.console) {
        window.console = {
            log: function () {}
        };
    }
    if (!window.console.warn) {
        window.console.warn = function (msg) {
            this.log('warn: ' + msg);
        };
    }

    // Register pause, resume and deviceready channels as events on document.
    channel.onPause = cordova.addDocumentEventHandler('pause');
    channel.onResume = cordova.addDocumentEventHandler('resume');
    channel.onActivated = cordova.addDocumentEventHandler('activated');
    channel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');

    // Listen for DOMContentLoaded and notify our channel subscribers.
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        channel.onDOMContentLoaded.fire();
    } else {
        document.addEventListener('DOMContentLoaded', function () {
            channel.onDOMContentLoaded.fire();
        }, false);
    }

    // _nativeReady is global variable that the native side can set
    // to signify that the native code is ready. It is a global since
    // it may be called before any cordova JS is ready.
    if (window._nativeReady) {
        channel.onNativeReady.fire();
    }

    modulemapper.clobbers('cordova', 'cordova');
    modulemapper.clobbers('cordova/exec', 'cordova.exec');
    modulemapper.clobbers('cordova/exec', 'Cordova.exec');

    // Call the platform-specific initialization.
    platform.bootstrap && platform.bootstrap();

    // Wrap in a setTimeout to support the use-case of having plugin JS appended to cordova.js.
    // The delay allows the attached modules to be defined before the plugin loader looks for them.
    setTimeout(function () {
        pluginloader.load(function () {
            channel.onPluginsReady.fire();
        });
    }, 0);

    /**
     * Create all cordova objects once native side is ready.
     */
    channel.join(function () {
        modulemapper.mapModules(window);

        platform.initialize && platform.initialize();

        // Fire event to notify that all objects are created
        channel.onCordovaReady.fire();

        // Fire onDeviceReady event once page has fully loaded, all
        // constructors have run and cordova info has been received from native
        // side.
        channel.join(function () {
            require('cordova').fireDocumentEvent('deviceready');
        }, channel.deviceReadyChannelsArray);

    }, platformInitChannelsArray);

});
    
// file: src/common/argscheck.js
define("cordova/argscheck", function(require, exports, module) {

    var utils = require('cordova/utils');

    var moduleExports = module.exports;

    var typeMap = {
        'A': 'Array',
        'D': 'Date',
        'N': 'Number',
        'S': 'String',
        'F': 'Function',
        'O': 'Object'
    };

    // 提取参数名称
    function extractParamName (callee, argIndex) {
        // exec() 方法用于检索字符串中的正则表达式的匹配，返回一个数组
        return (/.*?\((.*?)\)/).exec(callee)[1].split(', ')[argIndex];
    }

    // spec - 参数的类型拼接的字符串，如：ADN 表示(Array、Date、Number)
    function checkArgs (spec, functionName, args, opt_callee) {
        if (!moduleExports.enableChecks) {
            return;
        }
        var errMsg = null;
        var typeName;
        for (var i = 0; i < spec.length; ++i) {
            var c = spec.charAt(i);
            var cUpper = c.toUpperCase();
            var arg = args[i];
            // Asterix means allow anything.
            if (c === '*') {
                continue;
            }
            typeName = utils.typeName(arg);
            if ((arg === null || arg === undefined) && c === cUpper) {
                continue;
            }
            if (typeName !== typeMap[cUpper]) {
                errMsg = 'Expected ' + typeMap[cUpper];
                break;
            }
        }
        if (errMsg) {
            errMsg += ', but got ' + typeName + '.';
            errMsg = 'Wrong type for parameter "' + extractParamName(opt_callee || args.callee, i) + '" of ' + functionName + ': ' + errMsg;
            // Don't log when running unit tests.
            if (typeof jasmine === 'undefined') {
                console.error(errMsg);
            }
            throw TypeError(errMsg);
        }
    }

    function getValue (value, defaultValue) {
        return value === undefined ? defaultValue : value;
    }

    moduleExports.checkArgs = checkArgs;
    moduleExports.getValue = getValue;
    moduleExports.enableChecks = true;

});

define("cordova/exec", function(require, exports, module) {

    /*global require, module, atob, document */
    //atob() 函数能够解码通过base-64编码的字符串数据。
    //相反地，btoa() 函数能够从二进制数据“字符串”创建一个base-64编码的ASCII字符串。

    /**
     * 创建一个`iframe`桥接用于通知原生代码 about queued commands.
     */
    var cordova = require('cordova'),
        utils = require('cordova/utils'),
        base64 = require('cordova/base64'),
        execIframe,
        commandQueue = [], // Contains pending JS->Native messages.
        isInContextOfEvalJs = 0,
        failSafeTimerId = 0;

    // 将js的参数转化成可以传递给原生平台的参数类型，做的事主要就是处理`ArrayBuffer`
    // ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。
    // ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容
    function massageArgsJsToNative(args) {
        if (!args || utils.typeName(args) != 'Array') {
            return args;
        }
        var ret = [];
        args.forEach(function(arg, i) {
            if (utils.typeName(arg) == 'ArrayBuffer') {
                ret.push({
                    'CDVType': 'ArrayBuffer',
                    'data': base64.fromArrayBuffer(arg)
                });
            } else {
                ret.push(arg);
            }
        });
        return ret;
    }

    // 篡改Message NativeToJs
    function massageMessageNativeToJs(message) {
        if (message.CDVType == 'ArrayBuffer') {
            var stringToArrayBuffer = function(str) {
                var ret = new Uint8Array(str.length);
                for (var i = 0; i < str.length; i++) {
                    ret[i] = str.charCodeAt(i);
                }
                return ret.buffer;
            };
            var base64ToArrayBuffer = function(b64) {
                return stringToArrayBuffer(atob(b64));
            };
            message = base64ToArrayBuffer(message.data);
        }
        return message;
    }

    function convertMessageToArgsNativeToJs(message) {
        var args = [];
        if (!message || !message.hasOwnProperty('CDVType')) {
            args.push(message);
        } else if (message.CDVType == 'MultiPart') {
            message.messages.forEach(function(e) {
                args.push(massageMessageNativeToJs(e));
            });
        } else {
            args.push(massageMessageNativeToJs(message));
        }
        return args;
    }

    // 构造方法
    function iOSExec() {

        var successCallback, failCallback, service, action, actionArgs;
        var callbackId = null;

        if (typeof arguments[0] !== 'string') {
            successCallback = arguments[0];
            failCallback = arguments[1];
            service = arguments[2];
            action = arguments[3];
            actionArgs = arguments[4];

            // Since we need to maintain backwards compatibility, we have to pass
            // an invalid callbackId even if no callback was provided since plugins
            // will be expecting it. The Cordova.exec() implementation allocates
            // an invalid callbackId and passes it even if no callbacks were given.
            callbackId = 'INVALID';
        } else {
            throw new Error('The old format of this exec call has been removed (deprecated since 2.1). Change to: ' +
                'cordova.exec(null, null, \'Service\', \'action\', [ arg1, arg2 ]);'
            );
        }

        // If actionArgs is not provided, default to an empty array
        actionArgs = actionArgs || [];

        // Register the callbacks and add the callbackId to the positional
        // arguments if given.
        if (successCallback || failCallback) {
            callbackId = service + cordova.callbackId++;
            cordova.callbacks[callbackId] =
                {success:successCallback, fail:failCallback};
        }

        actionArgs = massageArgsJsToNative(actionArgs);

        var command = [callbackId, service, action, actionArgs];

        // Stringify and queue the command. We stringify to command now to
        // effectively clone the command arguments in case they are mutated before
        // the command is executed.
        commandQueue.push(JSON.stringify(command));

        // If we're in the context of a stringByEvaluatingJavaScriptFromString call,
        // then the queue will be flushed when it returns; no need for a poke.
        // Also, if there is already a command in the queue, then we've already
        // poked the native side, so there is no reason to do so again.
        if (!isInContextOfEvalJs && commandQueue.length == 1) {
            pokeNative();
        }
    }

    // CB-10530
    // 判断iframe是否被移除，iframe being unloaded or removed during the poke
    function proxyChanged() {
        var cexec = cordovaExec();
        
        return (execProxy !== cexec && // proxy objects are different
                iOSExec !== cexec      // proxy object is not the current iOSExec
                );
    }

    // CB-10106
    function handleBridgeChange() {
        // 如果iframe被移除或者重载，将commandQueue的任务全部执行，清空commandQueue
        if (proxyChanged()) { 
            var commandString = commandQueue.shift();
            while(commandString) {
                var command = JSON.parse(commandString);
                var callbackId = command[0];
                var service = command[1];
                var action = command[2];
                var actionArgs = command[3];
                var callbacks = cordova.callbacks[callbackId] || {};
                
                execProxy(callbacks.success, callbacks.fail, service, action, actionArgs);
                
                commandString = commandQueue.shift();
            };
            return true;
        }
        
        return false;
    }

    function pokeNative() {
        // CB-5488 - Don't attempt to create iframe before document.body is available.
        // 使用runloop等待`document.body`可用后再创建`iframe`
        if (!document.body) {
            setTimeout(pokeNative);
            return;
        }
        
        // Check if they've removed it from the DOM, and put it back if so.
        if (execIframe && execIframe.contentWindow) {
            execIframe.contentWindow.location = 'gap://ready';
        } else {
            execIframe = document.createElement('iframe');
            execIframe.style.display = 'none';
            execIframe.src = 'gap://ready';
            document.body.appendChild(execIframe);
        }

        // Use a timer to protect against iframe being unloaded during the poke (CB-7735).
        // This makes the bridge ~ 7% slower, but works around the poke getting lost
        // when the iframe is removed from the DOM.
        // An onunload listener could be used in the case where the iframe has just been
        // created, but since unload events fire only once, it doesn't work in the normal
        // case of iframe reuse (where unload will have already fired due to the attempted
        // navigation of the page).
        failSafeTimerId = setTimeout(function() {
            if (commandQueue.length) {
                // CB-10106 - flush the queue on bridge change
                if (!handleBridgeChange()) {
                    pokeNative();
                }
            }
        }, 50); // Making this > 0 improves performance (marginally) in the normal case (where it doesn't fire).
    }

    iOSExec.nativeFetchMessages = function() {
        // Stop listing for window detatch once native side confirms poke.
        // 一旦原生平台确认了poke事件，立即停止监听window的事件
        if (failSafeTimerId) {
            clearTimeout(failSafeTimerId);
            failSafeTimerId = 0;
        }
        // Each entry in commandQueue is a JSON string already.
        if (!commandQueue.length) {
            return '';
        }
        var json = '[' + commandQueue.join(',') + ']';
        commandQueue.length = 0;
        return json;
    };

    iOSExec.nativeCallback = function(callbackId, status, message, keepCallback, debug) {
        return iOSExec.nativeEvalAndFetch(function() {
            var success = status === 0 || status === 1;
            var args = convertMessageToArgsNativeToJs(message);
            function nc2() {
                cordova.callbackFromNative(callbackId, success, status, args, keepCallback);
            }
            setTimeout(nc2, 0);
        });
    };

    iOSExec.nativeEvalAndFetch = function(func) {
        // This shouldn't be nested, but better to be safe.
        isInContextOfEvalJs++;
        try {
            func();
            return iOSExec.nativeFetchMessages();
        } finally {
            isInContextOfEvalJs--;
        }
    };

    // Proxy the exec for bridge changes. See CB-10106

    function cordovaExec() {
        var cexec = require('cordova/exec');
        var cexec_valid = (typeof cexec.nativeFetchMessages === 'function') && (typeof cexec.nativeEvalAndFetch === 'function') && (typeof cexec.nativeCallback === 'function');
        return (cexec_valid && execProxy !== cexec)? cexec : iOSExec;
    }
    
    // 构造方法 生成新的Proxy
    function execProxy() {
        cordovaExec().apply(null, arguments);
    };

    execProxy.nativeFetchMessages = function() {
        return cordovaExec().nativeFetchMessages.apply(null, arguments);
    };

    execProxy.nativeEvalAndFetch = function() {
        return cordovaExec().nativeEvalAndFetch.apply(null, arguments);
    };

    execProxy.nativeCallback = function() {
        return cordovaExec().nativeCallback.apply(null, arguments);
    };

    module.exports = execProxy;

});

define("cordova/modulemapper", function(require, exports, module) {

    var builder = require('cordova/builder');
    var moduleMap = define.moduleMap; // eslint-disable-line no-undef
    var symbolList;
    var deprecationMap;

    exports.reset = function () {
        symbolList = [];
        deprecationMap = {};
    };

    function addEntry (strategy, moduleName, symbolPath, opt_deprecationMessage) {
        if (!(moduleName in moduleMap)) {
            throw new Error('Module ' + moduleName + ' does not exist.');
        }
        symbolList.push(strategy, moduleName, symbolPath);
        if (opt_deprecationMessage) {
            deprecationMap[symbolPath] = opt_deprecationMessage;
        }
    }

    // Note: Android 2.3 does have Function.bind().
    exports.clobbers = function (moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('c', moduleName, symbolPath, opt_deprecationMessage);
    };

    exports.merges = function (moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('m', moduleName, symbolPath, opt_deprecationMessage);
    };

    exports.defaults = function (moduleName, symbolPath, opt_deprecationMessage) {
        addEntry('d', moduleName, symbolPath, opt_deprecationMessage);
    };

    exports.runs = function (moduleName) {
        addEntry('r', moduleName, null);
    };

    function prepareNamespace (symbolPath, context) {
        if (!symbolPath) {
            return context;
        }
        var parts = symbolPath.split('.');
        var cur = context;
        for (var i = 0, part; part = parts[i]; ++i) { // eslint-disable-line no-cond-assign
            cur = cur[part] = cur[part] || {};
        }
        return cur;
    }

    exports.mapModules = function (context) {
        var origSymbols = {};
        context.CDV_origSymbols = origSymbols;
        for (var i = 0, len = symbolList.length; i < len; i += 3) {
            var strategy = symbolList[i];
            var moduleName = symbolList[i + 1];
            var module = require(moduleName);
            // <runs/>
            if (strategy === 'r') {
                continue;
            }
            var symbolPath = symbolList[i + 2];
            var lastDot = symbolPath.lastIndexOf('.');
            var namespace = symbolPath.substr(0, lastDot);
            var lastName = symbolPath.substr(lastDot + 1);

            var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;
            var parentObj = prepareNamespace(namespace, context);
            var target = parentObj[lastName];

            if (strategy === 'm' && target) {
                builder.recursiveMerge(target, module);
            } else if ((strategy === 'd' && !target) || (strategy !== 'd')) {
                if (!(symbolPath in origSymbols)) {
                    origSymbols[symbolPath] = target;
                }
                builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);
            }
        }
    };

    exports.getOriginalSymbol = function (context, symbolPath) {
        var origSymbols = context.CDV_origSymbols;
        if (origSymbols && (symbolPath in origSymbols)) {
            return origSymbols[symbolPath];
        }
        var parts = symbolPath.split('.');
        var obj = context;
        for (var i = 0; i < parts.length; ++i) {
            obj = obj && obj[parts[i]];
        }
        return obj;
    };

    exports.reset();

});

define("cordova/pluginloader", function(require, exports, module) {

    var modulemapper = require('cordova/modulemapper');

    // Helper function to inject a <script> tag.
    // Exported for testing.
    exports.injectScript = function (url, onload, onerror) {
        var script = document.createElement('script');
        // onload fires even when script fails loads with an error.
        script.onload = onload;
        // onerror fires for malformed URLs.
        script.onerror = onerror;
        script.src = url;
        document.head.appendChild(script);
    };

    function injectIfNecessary (id, url, onload, onerror) {
        onerror = onerror || onload;
        if (id in define.moduleMap) { // eslint-disable-line no-undef
            onload();
        } else {
            exports.injectScript(url, function () {
                if (id in define.moduleMap) { // eslint-disable-line no-undef
                    onload();
                } else {
                    onerror();
                }
            }, onerror);
        }
    }

    function onScriptLoadingComplete (moduleList, finishPluginLoading) {
        // Loop through all the plugins and then through their clobbers and merges.
        for (var i = 0, module; module = moduleList[i]; i++) { // eslint-disable-line no-cond-assign
            if (module.clobbers && module.clobbers.length) {
                for (var j = 0; j < module.clobbers.length; j++) {
                    modulemapper.clobbers(module.id, module.clobbers[j]);
                }
            }

            if (module.merges && module.merges.length) {
                for (var k = 0; k < module.merges.length; k++) {
                    modulemapper.merges(module.id, module.merges[k]);
                }
            }

            // Finally, if runs is truthy we want to simply require() the module.
            if (module.runs) {
                modulemapper.runs(module.id);
            }
        }

        finishPluginLoading();
    }

    // Handler for the cordova_plugins.js content.
    // See plugman's plugin_loader.js for the details of this object.
    // This function is only called if the really is a plugins array that isn't empty.
    // Otherwise the onerror response handler will just call finishPluginLoading().
    function handlePluginsObject (path, moduleList, finishPluginLoading) {
        // Now inject the scripts.
        var scriptCounter = moduleList.length;

        if (!scriptCounter) {
            finishPluginLoading();
            return;
        }
        function scriptLoadedCallback () {
            if (!--scriptCounter) {
                onScriptLoadingComplete(moduleList, finishPluginLoading);
            }
        }

        for (var i = 0; i < moduleList.length; i++) {
            injectIfNecessary(moduleList[i].id, path + moduleList[i].file, scriptLoadedCallback);
        }
    }

    function findCordovaPath () {
        var path = null;
        var scripts = document.getElementsByTagName('script');
        var term = '/cordova.js';
        for (var n = scripts.length - 1; n > -1; n--) {
            var src = scripts[n].src.replace(/\?.*$/, ''); // Strip any query param (CB-6007).
            if (src.indexOf(term) === (src.length - term.length)) {
                path = src.substring(0, src.length - term.length) + '/';
                break;
            }
        }
        return path;
    }

    // Tries to load all plugins' js-modules.
    // This is an async process, but onDeviceReady is blocked on onPluginsReady.
    // onPluginsReady is fired when there are no plugins to load, or they are all done.
    exports.load = function (callback) {
        var pathPrefix = findCordovaPath();
        if (pathPrefix === null) {
            console.log('Could not find cordova.js script tag. Plugin loading may fail.');
            pathPrefix = '';
        }
        injectIfNecessary('cordova/plugin_list', pathPrefix + 'cordova_plugins.js', function () {
            var moduleList = require('cordova/plugin_list');
            handlePluginsObject(pathPrefix, moduleList, callback);
        }, callback);
    };

});

define("cordova/platform", function(require, exports, module) {

    module.exports = {
        id: 'ios',
        bootstrap: function () {
            // Attach the console polyfill that is iOS-only to window.console
            // see the file under plugin/ios/console.js
            require('cordova/modulemapper').clobbers('cordova/plugin/ios/console', 'window.console');

            require('cordova/channel').onNativeReady.fire();
        }
    };
});

define("cordova/builder", function(require, exports, module) {

    var utils = require('cordova/utils');

    function each (objects, func, context) {
        for (var prop in objects) {
            if (objects.hasOwnProperty(prop)) {
                func.apply(context, [objects[prop], prop]);
            }
        }
    }

    function clobber (obj, key, value) {
        exports.replaceHookForTesting(obj, key);
        var needsProperty = false;
        try {
            obj[key] = value;
        } catch (e) {
            needsProperty = true;
        }
        // Getters can only be overridden by getters.
        if (needsProperty || obj[key] !== value) {
            utils.defineGetter(obj, key, function () {
                return value;
            });
        }
    }

    function assignOrWrapInDeprecateGetter (obj, key, value, message) {
        if (message) {
            utils.defineGetter(obj, key, function () {
                console.log(message);
                delete obj[key];
                clobber(obj, key, value);
                return value;
            });
        } else {
            clobber(obj, key, value);
        }
    }

    function include (parent, objects, clobber, merge) {
        each(objects, function (obj, key) {
            try {
                var result = obj.path ? require(obj.path) : {};

                if (clobber) {
                    // Clobber if it doesn't exist.
                    if (typeof parent[key] === 'undefined') {
                        assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                    } else if (typeof obj.path !== 'undefined') {
                        // If merging, merge properties onto parent, otherwise, clobber.
                        if (merge) {
                            recursiveMerge(parent[key], result);
                        } else {
                            assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                        }
                    }
                    result = parent[key];
                } else {
                    // Overwrite if not currently defined.
                    if (typeof parent[key] === 'undefined') {
                        assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);
                    } else {
                        // Set result to what already exists, so we can build children into it if they exist.
                        result = parent[key];
                    }
                }

                if (obj.children) {
                    include(result, obj.children, clobber, merge);
                }
            } catch (e) {
                utils.alert('Exception building Cordova JS globals: ' + e + ' for key "' + key + '"');
            }
        });
    }

    /**
     * Merge properties from one object onto another recursively.  Properties from
     * the src object will overwrite existing target property.
     *
     * @param target Object to merge properties into.
     * @param src Object to merge properties from.
     */
    function recursiveMerge (target, src) {
        for (var prop in src) {
            if (src.hasOwnProperty(prop)) {
                if (target.prototype && target.prototype.constructor === target) {
                    // If the target object is a constructor override off prototype.
                    clobber(target.prototype, prop, src[prop]);
                } else {
                    if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {
                        recursiveMerge(target[prop], src[prop]);
                    } else {
                        clobber(target, prop, src[prop]);
                    }
                }
            }
        }
    }

    exports.buildIntoButDoNotClobber = function (objects, target) {
        include(target, objects, false, false);
    };
    exports.buildIntoAndClobber = function (objects, target) {
        include(target, objects, true, false);
    };
    exports.buildIntoAndMerge = function (objects, target) {
        include(target, objects, true, true);
    };
    exports.recursiveMerge = recursiveMerge;
    exports.assignOrWrapInDeprecateGetter = assignOrWrapInDeprecateGetter;
    exports.replaceHookForTesting = function () {};

});

define("cordova/channel", function(require, exports, module) {

    var utils = require('cordova/utils');
    var nextGuid = 1;

    /**
     * Custom pub-sub "channel" that can have functions subscribed to it
     * This object is used to define and control firing of events for
     * cordova initialization, as well as for custom events thereafter.
     *
     * The order of events during page load and Cordova startup is as follows:
     *
     * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.
     * onNativeReady*              Internal event that indicates the Cordova native side is ready.
     * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.
     * onDeviceReady*              User event fired to indicate that Cordova is ready
     * onResume                    User event fired to indicate a start/resume lifecycle event
     * onPause                     User event fired to indicate a pause lifecycle event
     *
     * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.
     * All listeners that subscribe after the event is fired will be executed right away.
     *
     * The only Cordova events that user code should register for are:
     *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript
     *      pause                 App has moved to background
     *      resume                App has returned to foreground
     *
     * Listeners can be registered as:
     *      document.addEventListener("deviceready", myDeviceReadyListener, false);
     *      document.addEventListener("resume", myResumeListener, false);
     *      document.addEventListener("pause", myPauseListener, false);
     *
     * The DOM lifecycle events should be used for saving and restoring state
     *      window.onload
     *      window.onunload
     *
     */

    /**
     * Channel
     * @constructor
     * @param type  String the channel name
     */
    var Channel = function (type, sticky) {
        this.type = type;
        // Map of guid -> function.
        this.handlers = {};
        // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.
        this.state = sticky ? 1 : 0;
        // Used in sticky mode to remember args passed to fire().
        this.fireArgs = null;
        // Used by onHasSubscribersChange to know if there are any listeners.
        this.numHandlers = 0;
        // Function that is called when the first listener is subscribed, or when
        // the last listener is unsubscribed.
        this.onHasSubscribersChange = null;
    };
    
    var channel = {
        /**
         * Calls the provided function only after all of the channels specified
         * have been fired. All channels must be sticky channels.
         */
        join: function (h, c) {
            var len = c.length;
            var i = len;
            var f = function () {
                if (!(--i)) h();
            };
            for (var j = 0; j < len; j++) {
                if (c[j].state === 0) {
                    throw Error('Can only use join with sticky channels.');
                }
                c[j].subscribe(f);
            }
            if (!len) h();
        },
        /* eslint-disable no-return-assign */
        create: function (type) {
            return channel[type] = new Channel(type, false);
        },
        createSticky: function (type) {
            return channel[type] = new Channel(type, true);
        },
        /* eslint-enable no-return-assign */
        /**
         * cordova Channels that must fire before "deviceready" is fired.
         */
        deviceReadyChannelsArray: [],
        deviceReadyChannelsMap: {},

        /**
         * Indicate that a feature needs to be initialized before it is ready to be used.
         * This holds up Cordova's "deviceready" event until the feature has been initialized
         * and Cordova.initComplete(feature) is called.
         *
         * @param feature {String}     The unique feature name
         */
        waitForInitialization: function (feature) {
            if (feature) {
                var c = channel[feature] || this.createSticky(feature);
                this.deviceReadyChannelsMap[feature] = c;
                this.deviceReadyChannelsArray.push(c);
            }
        },

        /**
         * Indicate that initialization code has completed and the feature is ready to be used.
         *
         * @param feature {String}     The unique feature name
         */
        initializationComplete: function (feature) {
            var c = this.deviceReadyChannelsMap[feature];
            if (c) {
                c.fire();
            }
        }
    };

    function checkSubscriptionArgument (argument) {
        if (typeof argument !== 'function' && typeof argument.handleEvent !== 'function') {
            throw new Error(
                'Must provide a function or an EventListener object ' +
                    'implementing the handleEvent interface.'
            );
        }
    }

    /**
     * 订阅给定的`function`到`Channel`上，一旦`Channel.fire`被调用这个`function`也将被调用。
     * Optionally specify an execution context for the function
     * and a guid that can be used to stop subscribing to the channel.
     * Returns the guid.
     */
    Channel.prototype.subscribe = function (eventListenerOrFunction, eventListener) {
        checkSubscriptionArgument(eventListenerOrFunction);
        var handleEvent, guid;

        if (eventListenerOrFunction && typeof eventListenerOrFunction === 'object') {
            // Received an EventListener object implementing the handleEvent interface
            handleEvent = eventListenerOrFunction.handleEvent;
            eventListener = eventListenerOrFunction;
        } else {
            // Received a function to handle event
            handleEvent = eventListenerOrFunction;
        }

        if (this.state === 2) {
            handleEvent.apply(eventListener || this, this.fireArgs);
            return;
        }

        guid = eventListenerOrFunction.observer_guid;
        if (typeof eventListener === 'object') {
            handleEvent = utils.close(eventListener, handleEvent);
        }

        if (!guid) {
            // First time any channel has seen this subscriber
            guid = '' + nextGuid++;
        }
        handleEvent.observer_guid = guid;
        eventListenerOrFunction.observer_guid = guid;

        // Don't add the same handler more than once.
        if (!this.handlers[guid]) {
            this.handlers[guid] = handleEvent;
            this.numHandlers++;
            if (this.numHandlers === 1) {
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };

    /**
     * Unsubscribes the function with the given guid from the channel.
     */
    Channel.prototype.unsubscribe = function (eventListenerOrFunction) {
        checkSubscriptionArgument(eventListenerOrFunction);
        var handleEvent, guid, handler;

        if (eventListenerOrFunction && typeof eventListenerOrFunction === 'object') {
            // Received an EventListener object implementing the handleEvent interface
            handleEvent = eventListenerOrFunction.handleEvent;
        } else {
            // Received a function to handle event
            handleEvent = eventListenerOrFunction;
        }

        guid = handleEvent.observer_guid;
        handler = this.handlers[guid];
        if (handler) {
            delete this.handlers[guid];
            this.numHandlers--;
            if (this.numHandlers === 0) {
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };

    /**
     * Calls all functions subscribed to this channel.
     */
    Channel.prototype.fire = function (e) {
        var fail = false; // eslint-disable-line no-unused-vars
        var fireArgs = Array.prototype.slice.call(arguments);
        // Apply stickiness.
        if (this.state === 1) {
            this.state = 2;
            this.fireArgs = fireArgs;
        }
        if (this.numHandlers) {
            // Copy the values first so that it is safe to modify it from within
            // callbacks.
            var toCall = [];
            for (var item in this.handlers) {
                toCall.push(this.handlers[item]);
            }
            for (var i = 0; i < toCall.length; ++i) {
                toCall[i].apply(this, fireArgs);
            }
            if (this.state === 2 && this.numHandlers) {
                this.numHandlers = 0;
                this.handlers = {};
                this.onHasSubscribersChange && this.onHasSubscribersChange();
            }
        }
    };

    // defining them here so they are ready super fast!
    // DOM event that is received when the web page is loaded and parsed.
    channel.createSticky('onDOMContentLoaded');

    // Event to indicate the Cordova native side is ready.
    channel.createSticky('onNativeReady');

    // Event to indicate that all Cordova JavaScript objects have been created
    // and it's time to run plugin constructors.
    channel.createSticky('onCordovaReady');

    // Event to indicate that all automatically loaded JS plugins are loaded and ready.
    // FIXME remove this
    channel.createSticky('onPluginsReady');

    // Event to indicate that Cordova is ready
    channel.createSticky('onDeviceReady');

    // Event to indicate a resume lifecycle event
    channel.create('onResume');

    // Event to indicate a pause lifecycle event
    channel.create('onPause');

    // Channels that must fire before "deviceready" is fired.
    channel.waitForInitialization('onCordovaReady');
    channel.waitForInitialization('onDOMContentLoaded');

    module.exports = channel;

});

// js通用的函数和功能
define("cordova/utils", function(require, exports, module) {

    var utils = exports;

    /**
     * Defines a property getter / setter for obj[key].
     */
    utils.defineGetterSetter = function (obj, key, getFunc, opt_setFunc) {
        if (Object.defineProperty) {
            var desc = {
                get: getFunc,
                configurable: true
            };
            if (opt_setFunc) {
                desc.set = opt_setFunc;
            }
            Object.defineProperty(obj, key, desc);
        } else {
            obj.__defineGetter__(key, getFunc);
            if (opt_setFunc) {
                obj.__defineSetter__(key, opt_setFunc);
            }
        }
    };

    /**
     * Defines a property getter for obj[key].
     */
    utils.defineGetter = utils.defineGetterSetter;

    utils.arrayIndexOf = function (a, item) {
        if (a.indexOf) {
            return a.indexOf(item);
        }
        var len = a.length;
        for (var i = 0; i < len; ++i) {
            if (a[i] === item) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Returns whether the item was found in the array.
     */
    utils.arrayRemove = function (a, item) {
        var index = utils.arrayIndexOf(a, item);
        if (index !== -1) {
            a.splice(index, 1);
        }
        return index !== -1;
    };

    utils.typeName = function (val) {
        // Object.prototype.toString.call() 返回数据类型，例如：[Object Array] 
        return Object.prototype.toString.call(val).slice(8, -1);
    };

    /**
     * Returns an indication of whether the argument is an array or not
     */
    utils.isArray = Array.isArray ||
                    function (a) { return utils.typeName(a) === 'Array'; };

    /**
     * Returns an indication of whether the argument is a Date or not
     */
    utils.isDate = function (d) {
        return (d instanceof Date);
    };

    /**
     * Does a deep clone of the object.
     */
    utils.clone = function (obj) {
        if (!obj || typeof obj === 'function' || utils.isDate(obj) || typeof obj !== 'object') {
            return obj;
        }

        var retVal, i;

        if (utils.isArray(obj)) {
            retVal = [];
            for (i = 0; i < obj.length; ++i) {
                retVal.push(utils.clone(obj[i]));
            }
            return retVal;
        }

        retVal = {};
        for (i in obj) {
            // https://issues.apache.org/jira/browse/CB-11522 'unknown' type may be returned in
            // custom protocol activation case on Windows Phone 8.1 causing "No such interface supported" exception
            // on cloning.
            if ((!(i in retVal) || retVal[i] !== obj[i]) && typeof obj[i] !== 'undefined' && typeof obj[i] !== 'unknown') { // eslint-disable-line valid-typeof
                retVal[i] = utils.clone(obj[i]);
            }
        }
        return retVal;
    };

    /**
     * Returns a wrapped version of the function
     */
    utils.close = function (context, func, params) {
        return function () {
            var args = params || arguments;
            return func.apply(context, args);
        };
    };

    // ------------------------------------------------------------------------------
    function UUIDcreatePart (length) {
        var uuidpart = '';
        for (var i = 0; i < length; i++) {
            var uuidchar = parseInt((Math.random() * 256), 10).toString(16);
            if (uuidchar.length === 1) {
                uuidchar = '0' + uuidchar;
            }
            uuidpart += uuidchar;
        }
        return uuidpart;
    }

    /**
     * Create a UUID
     */
    utils.createUUID = function () {
        return UUIDcreatePart(4) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(2) + '-' +
            UUIDcreatePart(6);
    };

    /**
     * Extends 从父对象继承一个子对象
     */
    utils.extend = (function () {
        // 用于创建原型链的代理
        var F = function () {};
        // extend Child from Parent
        return function (Child, Parent) {

            F.prototype = Parent.prototype;
            Child.prototype = new F();
            Child.__super__ = Parent.prototype;
            Child.prototype.constructor = Child;
        };
    }());

    /**
     * Alerts a message in any available way: alert or console.log.
     */
    utils.alert = function (msg) {
        if (window.alert) {
            window.alert(msg);
        } else if (console && console.log) {
            console.log(msg);
        }
    };

});

define("cordova/plugin/ios/console", function(require, exports, module) {

    //------------------------------------------------------------------------------

    var logger = require('cordova/plugin/ios/logger');

    //------------------------------------------------------------------------------
    // object that we're exporting
    //------------------------------------------------------------------------------
    var console = module.exports;

    //------------------------------------------------------------------------------
    // copy of the original console object
    //------------------------------------------------------------------------------
    var WinConsole = window.console;

    //------------------------------------------------------------------------------
    // whether to use the logger
    //------------------------------------------------------------------------------
    var UseLogger = false;

    //------------------------------------------------------------------------------
    // Timers
    //------------------------------------------------------------------------------
    var Timers = {};

    //------------------------------------------------------------------------------
    // used for unimplemented methods
    //------------------------------------------------------------------------------
    function noop() {}

    //------------------------------------------------------------------------------
    // used for unimplemented methods
    //------------------------------------------------------------------------------
    console.useLogger = function (value) {
        if (arguments.length) UseLogger = !!value;

        if (UseLogger) {
            if (logger.useConsole()) {
                throw new Error("console and logger are too intertwingly");
            }
        }

        return UseLogger;
    };

    //------------------------------------------------------------------------------
    console.log = function() {
        if (logger.useConsole()) return;
        logger.log.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.error = function() {
        if (logger.useConsole()) return;
        logger.error.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.warn = function() {
        if (logger.useConsole()) return;
        logger.warn.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.info = function() {
        if (logger.useConsole()) return;
        logger.info.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.debug = function() {
        if (logger.useConsole()) return;
        logger.debug.apply(logger, [].slice.call(arguments));
    };

    //------------------------------------------------------------------------------
    console.assert = function(expression) {
        if (expression) return;

        var message = logger.format.apply(logger.format, [].slice.call(arguments, 1));
        console.log("ASSERT: " + message);
    };

    //------------------------------------------------------------------------------
    console.clear = function() {};

    //------------------------------------------------------------------------------
    console.dir = function(object) {
        console.log("%o", object);
    };

    //------------------------------------------------------------------------------
    console.dirxml = function(node) {
        console.log(node.innerHTML);
    };

    //------------------------------------------------------------------------------
    console.trace = noop;

    //------------------------------------------------------------------------------
    console.group = console.log;

    //------------------------------------------------------------------------------
    console.groupCollapsed = console.log;

    //------------------------------------------------------------------------------
    console.groupEnd = noop;

    //------------------------------------------------------------------------------
    console.time = function(name) {
        Timers[name] = new Date().valueOf();
    };

    //------------------------------------------------------------------------------
    console.timeEnd = function(name) {
        var timeStart = Timers[name];
        if (!timeStart) {
            console.warn("unknown timer: " + name);
            return;
        }

        var timeElapsed = new Date().valueOf() - timeStart;
        console.log(name + ": " + timeElapsed + "ms");
    };

    //------------------------------------------------------------------------------
    console.timeStamp = noop;

    //------------------------------------------------------------------------------
    console.profile = noop;

    //------------------------------------------------------------------------------
    console.profileEnd = noop;

    //------------------------------------------------------------------------------
    console.count = noop;

    //------------------------------------------------------------------------------
    console.exception = console.log;

    //------------------------------------------------------------------------------
    console.table = function(data, columns) {
        console.log("%o", data);
    };

    //------------------------------------------------------------------------------
    // return a new function that calls both functions passed as args
    //------------------------------------------------------------------------------
    function wrappedOrigCall(orgFunc, newFunc) {
        return function() {
            var args = [].slice.call(arguments);
            try { orgFunc.apply(WinConsole, args); } catch (e) {}
            try { newFunc.apply(console,    args); } catch (e) {}
        };
    }

    //------------------------------------------------------------------------------
    // For every function that exists in the original console object, that
    // also exists in the new console object, wrap the new console method
    // with one that calls both
    //------------------------------------------------------------------------------
    for (var key in console) {
        if (typeof WinConsole[key] == "function") {
            console[key] = wrappedOrigCall(WinConsole[key], console[key]);
        }
    }

});

// file: /Users/dpogue/Coding/cordova-ios/cordova-js-src/plugin/ios/logger.js
define("cordova/plugin/ios/logger", function(require, exports, module) {

    //------------------------------------------------------------------------------
    // The logger module exports the following properties/functions:
    //
    // LOG                          - constant for the level LOG
    // ERROR                        - constant for the level ERROR
    // WARN                         - constant for the level WARN
    // INFO                         - constant for the level INFO
    // DEBUG                        - constant for the level DEBUG
    // logLevel()                   - returns current log level
    // logLevel(value)              - sets and returns a new log level
    // useConsole()                 - returns whether logger is using console
    // useConsole(value)            - sets and returns whether logger is using console
    // log(message,...)             - logs a message at level LOG
    // error(message,...)           - logs a message at level ERROR
    // warn(message,...)            - logs a message at level WARN
    // info(message,...)            - logs a message at level INFO
    // debug(message,...)           - logs a message at level DEBUG
    // logLevel(level,message,...)  - logs a message specified level
    //
    //------------------------------------------------------------------------------

    var logger = exports;

    var exec    = require('cordova/exec');

    var UseConsole   = false;
    var UseLogger    = true;
    var Queued       = [];
    var DeviceReady  = false;
    var CurrentLevel;

    var originalConsole = console;

    /**
     * Logging levels
     */

    var Levels = [
        "LOG",
        "ERROR",
        "WARN",
        "INFO",
        "DEBUG"
    ];

    /*
    * add the logging levels to the logger object and
    * to a separate levelsMap object for testing
    */

    var LevelsMap = {};
    for (var i=0; i<Levels.length; i++) {
        var level = Levels[i];
        LevelsMap[level] = i;
        logger[level]    = level;
    }

    CurrentLevel = LevelsMap.WARN;

    /**
     * Getter/Setter for the logging level
     *
     * Returns the current logging level.
     *
     * When a value is passed, sets the logging level to that value.
     * The values should be one of the following constants:
     *    logger.LOG
     *    logger.ERROR
     *    logger.WARN
     *    logger.INFO
     *    logger.DEBUG
     *
     * The value used determines which messages get printed.  The logging
     * values above are in order, and only messages logged at the logging
     * level or above will actually be displayed to the user.  E.g., the
     * default level is WARN, so only messages logged with LOG, ERROR, or
     * WARN will be displayed; INFO and DEBUG messages will be ignored.
     */
    logger.level = function (value) {
        if (arguments.length) {
            if (LevelsMap[value] === null) {
                throw new Error("invalid logging level: " + value);
            }
            CurrentLevel = LevelsMap[value];
        }

        return Levels[CurrentLevel];
    };

    /**
     * Getter/Setter for the useConsole functionality
     *
     * When useConsole is true, the logger will log via the
     * browser 'console' object.
     */
    logger.useConsole = function (value) {
        if (arguments.length) UseConsole = !!value;

        if (UseConsole) {
            if (typeof console == "undefined") {
                throw new Error("global console object is not defined");
            }

            if (typeof console.log != "function") {
                throw new Error("global console object does not have a log function");
            }

            if (typeof console.useLogger == "function") {
                if (console.useLogger()) {
                    throw new Error("console and logger are too intertwingly");
                }
            }
        }

        return UseConsole;
    };

    /**
     * Getter/Setter for the useLogger functionality
     *
     * When useLogger is true, the logger will log via the
     * native Logger plugin.
     */
    logger.useLogger = function (value) {
        // Enforce boolean
        if (arguments.length) UseLogger = !!value;
        return UseLogger;
    };

    /**
     * Logs a message at the LOG level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.log   = function(message) { logWithArgs("LOG",   arguments); };

    /**
     * Logs a message at the ERROR level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.error = function(message) { logWithArgs("ERROR", arguments); };

    /**
     * Logs a message at the WARN level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.warn  = function(message) { logWithArgs("WARN",  arguments); };

    /**
     * Logs a message at the INFO level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.info  = function(message) { logWithArgs("INFO",  arguments); };

    /**
     * Logs a message at the DEBUG level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.debug = function(message) { logWithArgs("DEBUG", arguments); };

    // log at the specified level with args
    function logWithArgs(level, args) {
        args = [level].concat([].slice.call(args));
        logger.logLevel.apply(logger, args);
    }

    // return the correct formatString for an object
    function formatStringForMessage(message) {
        return (typeof message === "string") ? "" : "%o"; 
    }

    /**
     * Logs a message at the specified level.
     *
     * Parameters passed after message are used applied to
     * the message with utils.format()
     */
    logger.logLevel = function(level /* , ... */) {
        // format the message with the parameters
        var formatArgs = [].slice.call(arguments, 1);
        var fmtString = formatStringForMessage(formatArgs[0]);
        if (fmtString.length > 0){
            formatArgs.unshift(fmtString); // add formatString
        }

        var message    = logger.format.apply(logger.format, formatArgs);

        if (LevelsMap[level] === null) {
            throw new Error("invalid logging level: " + level);
        }

        if (LevelsMap[level] > CurrentLevel) return;

        // queue the message if not yet at deviceready
        if (!DeviceReady && !UseConsole) {
            Queued.push([level, message]);
            return;
        }

        // Log using the native logger if that is enabled
        if (UseLogger) {
            exec(null, null, "Console", "logLevel", [level, message]);
        }

        // Log using the console if that is enabled
        if (UseConsole) {
            // make sure console is not using logger
            if (console.useLogger()) {
                throw new Error("console and logger are too intertwingly");
            }

            // log to the console
            switch (level) {
                case logger.LOG:   originalConsole.log(message); break;
                case logger.ERROR: originalConsole.log("ERROR: " + message); break;
                case logger.WARN:  originalConsole.log("WARN: "  + message); break;
                case logger.INFO:  originalConsole.log("INFO: "  + message); break;
                case logger.DEBUG: originalConsole.log("DEBUG: " + message); break;
            }
        }
    };


    /**
     * Formats a string and arguments following it ala console.log()
     *
     * Any remaining arguments will be appended to the formatted string.
     *
     * for rationale, see FireBug's Console API:
     *    http://getfirebug.com/wiki/index.php/Console_API
     */
    logger.format = function(formatString, args) {
        return __format(arguments[0], [].slice.call(arguments,1)).join(' ');
    };


    //------------------------------------------------------------------------------
    /**
     * Formats a string and arguments following it ala vsprintf()
     *
     * format chars:
     *   %j - format arg as JSON
     *   %o - format arg as JSON
     *   %c - format arg as ''
     *   %% - replace with '%'
     * any other char following % will format it's
     * arg via toString().
     *
     * Returns an array containing the formatted string and any remaining
     * arguments.
     */
    function __format(formatString, args) {
        if (formatString === null || formatString === undefined) return [""];
        if (arguments.length == 1) return [formatString.toString()];

        if (typeof formatString != "string")
            formatString = formatString.toString();

        var pattern = /(.*?)%(.)(.*)/;
        var rest    = formatString;
        var result  = [];

        while (args.length) {
            var match = pattern.exec(rest);
            if (!match) break;

            var arg   = args.shift();
            rest = match[3];
            result.push(match[1]);

            if (match[2] == '%') {
                result.push('%');
                args.unshift(arg);
                continue;
            }

            result.push(__formatted(arg, match[2]));
        }

        result.push(rest);

        var remainingArgs = [].slice.call(args);
        remainingArgs.unshift(result.join(''));
        return remainingArgs;
    }

    function __formatted(object, formatChar) {

        try {
            switch(formatChar) {
                case 'j':
                case 'o': return JSON.stringify(object);
                case 'c': return '';
            }
        }
        catch (e) {
            return "error JSON.stringify()ing argument: " + e;
        }

        if ((object === null) || (object === undefined)) {
            return Object.prototype.toString.call(object);
        }

        return object.toString();
    }


    //------------------------------------------------------------------------------
    // when deviceready fires, log queued messages
    logger.__onDeviceReady = function() {
        if (DeviceReady) return;

        DeviceReady = true;

        for (var i=0; i<Queued.length; i++) {
            var messageArgs = Queued[i];
            logger.logLevel(messageArgs[0], messageArgs[1]);
        }

        Queued = null;
    };

    // add a deviceready event to log queued messages
    document.addEventListener("deviceready", logger.__onDeviceReady, false);

});

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////// 加载全局模块 cordova ///////////////////
window.cordova = require('cordova');
require('cordova/init');
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

</script>
